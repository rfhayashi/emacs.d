#+title: Emacs Config
#+author: Rui Hayashi
#+PROPERTY: header-args :results silent :tangle config.el :mkdirp yes

* Introduction
This is my emacs configuration.
This configuration is meant to be used with [[https://github.com/plexus/chemacs][chemacs]].
Since it is also based on [[https://github.com/raxod502/straight.el][Straight]], chemacs profile should activate it. E.g.

#+begin_src emacs-lisp :tangle no
  ; ~/.emacs-profiles.el example
  (("default" . ((user-emacs-directory . "<this repo dir>")
                 (straight-p . t))))
#+end_src

* Home directory
  Sets the home dir to a name so it can be injected later on.
  #+name: homedir
  #+begin_src emacs-lisp :tangle no :results value
    (getenv "HOME")
  #+end_src
* Hide menu/toolbar/scroolbar
  We don't want to use the mouse anyway :P
  We also want to use as much screen as possible
  #+begin_src emacs-lisp
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)

    (add-to-list 'default-frame-alist '(fullscreen . maximized))
  #+end_src
  
* Straight/use-package setup
  [[https://github.com/raxod502/straight.el][Straight]] let us have a functional package management.
  This section integrates straight and [[https://github.com/jwiegley/use-package][use-package]].
  #+begin_src emacs-lisp
    (setq straight-use-package-by-default t)

    (straight-use-package 'use-package)
  #+end_src

* Miscelaneous
** Disable backup files
   #+begin_src emacs-lisp
     (setq make-backup-files nil)
   #+end_src
** Enable which-key
   [[https://github.com/justbur/emacs-which-key][which-key]] shows the available key bindings in the mini buffer
   #+begin_src emacs-lisp
     (use-package
       which-key
       :config
       (which-key-mode))
   #+end_src
** Markdown/Json/Yaml modes
   Since we all end up editing some markdown/json/yaml every day.
   #+begin_src emacs-lisp
     (use-package
       markdown-mode)

     (use-package
       yaml-mode)

     (use-package
       json-mode)
   #+end_src
** Disable using tabs in indentation
   #+begin_src emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+end_src
** Edn parsing
   #+begin_src emacs-lisp
     (use-package parseedn)
   #+end_src
* Look and feel
** Theme
   Thank you Batsov. This is [[https://github.com/bbatsov/zenburn-emacs][beautiful]].
   #+begin_src emacs-lisp
     (use-package
       zenburn-theme
       :config
       (load-theme 'zenburn t))
   #+end_src
** Font
   #+begin_src emacs-lisp
     (set-frame-font "Source Code Pro 13" nil t)
   #+end_src
** Winum
   [[https://github.com/deb0ch/emacs-winum][Winum]] decorates windows with a number to make it easier to jump from one window to another.
   #+begin_src emacs-lisp
     (use-package winum
       :config
       (require 'winum)
       (winum-mode))
   #+end_src
** Winner mode
   Allows undo window configurations.
   #+begin_src emacs-lisp
     (winner-mode)
   #+end_src
** Modeline
   Using [[https://github.com/seagle0128/doom-modeline][Doom Modeline]]
   The first time this is loaded in a computer, run ~all-the-icons-install-fonts~ to install the proper fonts.
   #+begin_src emacs-lisp
     (use-package doom-modeline
       :custom
       (doom-modeline-height 25)
       :config
       (set-face-attribute 'mode-line nil :family "Source Code Pro" :height 100)
       (set-face-attribute 'mode-line-inactive nil :family "Source Code Prod" :height 100)
       :init
       (doom-modeline-mode 1))
   #+end_src
* Evil setup
  Modal editing + Emacs rocks and is a little [[https://github.com/emacs-evil/evil][evil]]
  [[https://github.com/emacs-evil/evil-collection][Evil Collection]] spare us the time of setting up evil.
  #+begin_src emacs-lisp
    (use-package
      evil
      :init
      (setq evil-want-keybinding nil)
      (setq evil-want-integration t)
      (setq evil-disable-insert-state-bindings t)
      :config
      (evil-mode 1))

    (use-package
      evil-collection
      :init
      (evil-collection-init)
      :custom
      (evil-collection-setup-minibuffer t))
  #+end_src
* Keybindings
  #+begin_src emacs-lisp
    (use-package corkey
      :straight (corkey
		 :type git
		 :host github
		 :branch "main"
		 :files ("corkey/corkey.el")
		 :repo "lambdaisland/corgi-packages")
      :config
      (global-corkey-mode 1)
      ;; Move to the front so these keys always have priority
      (setq minor-mode-map-alist
	    (cons
	     (cons 'corkey-mode corkey/keymap)
	     (delq corkey-mode minor-mode-map-alist))))

  #+end_src

* Auto Completion
  [[https://github.com/company-mode/company-mode][Company]] to the rescue
  #+begin_src emacs-lisp
    (use-package
      company
      :config
      (global-company-mode))
  #+end_src
* Structural Editing
  Because parenthesis matter, and [[https://www.emacswiki.org/emacs/ParEdit][paredit]] takes control of them.
  [[https://www.emacswiki.org/emacs/ShowParenMode][show-paren-mode]] shows matching parens.
  #+begin_src emacs-lisp
    (show-paren-mode)

    (defmacro user/setup-paredit-for (language)
      `(add-hook
	(quote ,(make-symbol (concat (symbol-name language) "-mode-hook")))
	#'enable-paredit-mode))

    (use-package
      paredit
      :config
      (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode))
  #+end_src
* Ivy
  [[https://github.com/abo-abo/swiper][Ivy]] provides a completion mechanism to find files, projects and other things.
  #+begin_src emacs-lisp
    (use-package counsel
      :custom
      (ivy-initial-inputs-alist nil)
      (ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
      :config
      (ivy-mode 1)
      (counsel-mode 1)
      :bind (:map ivy-minibuffer-map
             ("C-j" . ivy-next-line)
             ("C-k" . ivy-previous-line)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)))

    (use-package swiper
      :bind
      (:map evil-normal-state-map
            ("/" . swiper)))

    (use-package ivy-rich
      :init
      (ivy-rich-mode 1))
  #+end_src
* Magit
  Work with git with a little bit of [[https://magit.vc/][magit]]
  #+begin_src emacs-lisp
    (use-package
      magit)

    (use-package
      evil-magit)
  #+end_src
* Projectile
  Sets up [[https://github.com/bbatsov/projectile][Projectile]].
  #+begin_src emacs-lisp
    (use-package
     projectile
     :config
     (projectile-mode +1)
     :init
     (when (file-directory-p "~/dev")
       (setq projectile-project-search-path '("~/dev"))))

    (use-package counsel-projectile
      :config
      (counsel-projectile-mode))
  #+end_src
* Yasnippet
  #+begin_src emacs-lisp
    (use-package yasnippet
      :config
      (yas-global-mode 1))
  #+end_src
* Clojure
  Setup for working with clojure. Sets up [[https://github.com/clojure-emacs/cider][cider]] and [[https://github.com/snoe/clojure-lsp][clojure lsp]].

  #+begin_src clojure :tangle ~/.clojure/injections/deps.edn
    {}
  #+end_src

  #+begin_src clojure :tangle ~/.clojure/injections/src/portal.clj
    (ns portal
      (:require [portal.api :as portal]))

    (defonce portal* (atom nil))

    (defn instance []
      (reset! portal* (portal/open @portal*))
      @portal*)

    (defn send [v]
      (reset! (instance) v))

    (defn fetch []
      @(instance))

  #+end_src

  #+begin_src clojure :tangle ~/.clojure/injections/src/tap.clj
    (ns tap
      (:refer-clojure :exclude [>]))

    (defn m [message v]
      (tap> {:message message
             :tap v})
      v)

    (defn >-reader [form]
      `(let [t# ~form]
         (tap> t#)
         t#))

    (defmacro > [form]
      (>-reader form))

    (defn d-reader [form]
      `(let [t# ~form]
         (tap> {:code (pr-str (quote ~form))
                :tap t#})
         t#))

    (defmacro d [form]
      (d-reader form))
  #+end_src

  #+begin_src clojure :tangle ~/.clojure/injections/src/data_readers.clj
    {tap tap/>-reader
     tapd tap/d-reader}
  #+end_src

  #+begin_src clojure :tangle ~/.clojure/injections/src/user.clj
    (ns user
      (:require [tap]
                [portal]))

    (portal.api/tap)
  #+end_src

  #+begin_src clojure :tangle ~/.clojure/deps.edn :noweb yes
    {:aliases

     {; Linters
      :cljfmt {:deps {cljfmt/cljfmt {:mvn/version "0.6.4"}}
               :main-opts ["-m" "cljfmt.main"]}
      :nsorg {:deps {nsorg-cli/nsorg-cli {:mvn/version "0.3.1"}}
              :main-opts ["-m" "nsorg.cli"]}
      :outdated {:extra-deps {olical/depot {:mvn/version "1.8.4"}}
                 :main-opts ["-m" "depot.outdated.main"]}

      :oz {:extra-deps {metasoarous/oz {:mvn/version "1.6.0-alpha6"}}}
      :portal {:extra-deps {djblue/portal {:mvn/version "0.8.0"}}}
      :injections {:extra-deps {my/tap {:local/root "<<homedir()>>/.clojure/injections"}}}}}
  #+end_src

  #+begin_src clojure :tangle ~/.clojure/injections/project.clj
    (defproject my/tap "0.0.1-SNAPSHOT")
  #+end_src

  To use tap with leiningen, execute this block manually.
  #+begin_src bash :tangle no :noweb yes
    cd <<homedir()>>/.clojure/injections
    lein install
  #+end_src

  #+begin_src clojure :tangle ~/.lein/profiles.clj
    {:user
     {:dependencies        [[my/tap "0.0.1-SNAPSHOT"]
                            [djblue/portal "0.8.0"]]
      :injections          [(require 'tap)
                            (require 'portal)
                            (portal/tap)]}}
  #+end_src

  #+begin_src emacs-lisp
    (defun my/cider-test-run-focused-test ()
      "Run test around point"
      (interactive)
      (cider-load-buffer)
      (cider-test-run-test))

    (defun my/cider-test-run-ns-tests ()
      "Run namespace test"
      (interactive)
      (cider-load-buffer)
      (cider-test-run-ns-tests nil))

    (defun my/portal-cider-inspect-last-result ()
      (interactive)
      (let ((repl (cider-current-repl)))
        (nrepl-send-sync-request `("op" "eval" "code" "(portal/send *1)") repl)))

    (use-package clojure-mode
      :config
      (add-hook 'clojure-mode-hook #'enable-paredit-mode))

    (defun my/setup-matcher-combinators ()
      (cider-add-to-alist 'cider-jack-in-lein-plugins "cider/cider-nrepl" "0.25.5")

      (advice-add 'cider-ansi-color-string-p :override
                  (lambda (string) (string-match "\\[" string)))

      (advice-add 'cider-font-lock-as
                  :before
                  (lambda (&rest r)
                    (advice-add 'substring-no-properties :override #'identity)))
      (advice-add 'cider-font-lock-as
                  :after
                  (lambda (&rest r)
                    (advice-remove 'substring-no-properties #'identity))))

    (use-package cider
      :config
      (setq cider-save-file-on-load t)
      (setq cider-repl-pop-to-buffer-on-connect nil)
      (setq cider-test-defining-forms '("deftest" "defspec" "defflow"))
      (setq org-babel-clojure-backend 'cider)
      (setq clojure-toplevel-inside-comment-form t)
      (setq cider-clojure-cli-global-options "-A:portal -A:injections")
      (my/setup-matcher-combinators))

    (use-package lsp-mode
      :config
      (dolist (m '(clojure-mode
                   clojurec-mode
                   clojurescript-mode
                   clojurex-mode))
        (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
      (setq lsp-enable-indentation nil)
      (add-hook 'clojure-mode-hook #'lsp)
      (add-hook 'clojurec-mode-hook #'lsp)
      (add-hook 'clojurescript-mode-hook #'lsp))

    (use-package clj-refactor
      :config
      (clj-refactor-mode 1))
  #+end_src
* Scratch
  [[https://github.com/ffevotte/scratch.el][scratch]] make it easier to create scratch buffers. This is augmented with scratch-buffer-setup function
  by Protesilaos Stavrou ([[https://protesilaos.com/codelog/2020-08-03-emacs-custom-functions-galore/][See]]).
  #+begin_src emacs-lisp
    (use-package scratch
      :config
      (defun prot/scratch-buffer-setup ()
	"Add contents to `scratch' buffer and name it accordingly."
	(let* ((mode (format "%s" major-mode))
	       (string (concat "Scratch buffer for: " mode "\n\n")))
	  (when scratch-buffer
	    (save-excursion
	      (insert string)
	      (goto-char (point-min))
	      (comment-region (point-at-bol) (point-at-eol)))
	    (forward-line 2))
	  (rename-buffer (concat "*Scratch for " mode "*") t)))
      (add-hook 'scratch-create-buffer-hook 'prot/scratch-buffer-setup))
  #+end_src
* Org mode
  My [[https://orgmode.org/][org mode]] and [[https://github.com/org-roam/org-roam][org roam]] setup.
  #+begin_src emacs-lisp
    (with-eval-after-load 'org
      (require 'ob-shell)
      (require 'ob-clojure)
      (setq org-confirm-babel-evaluate nil)
      (setq org-ellipsis " ▾")
      (org-babel-lob-ingest (expand-file-name "babel.org" user-emacs-directory))
      (require 'org-tempo)
      (dolist (el '(("el" . "src emacs-lisp")
                    ("clj" . "src clojure")
                    ("bb" . "src clojure :backend babashka")
                    ("bash" . "src bash")))
        (add-to-list 'org-structure-template-alist el)))

    (use-package evil-org
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
                (lambda ()
                  (evil-org-set-key-theme)))
      (evil-org-set-key-theme '(textobjects insert navigation additional shift todo heading)))

    (defconst rfh/org-roam-dir "~/dev/org-roam")

    (use-package org-roam
      :config
      (setq org-roam-directory rfh/org-roam-dir)
      (setq org-roam-completion-system 'ivy)
      (add-hook 'after-init-hook 'org-roam-mode))

    (use-package company-org-roam
      :after company
      :straight (:host github :repo "org-roam/company-org-roam")
      :config
      (push 'company-org-roam company-backends))

    (defun my/org-mode-visual-fill ()
      (setq visual-fill-column-width 80)
      (visual-fill-column-mode 1)
      (visual-line-mode 1))

    (use-package visual-fill-column
      :hook (org-mode . my/org-mode-visual-fill))
  #+end_src
* Org Babel + Clojure
  Customizations on top of ob-clojure.
** Support for babashka
   Makes it possible to use [[https://github.com/borkdude/babashka][babashka]] via [[https://orgmode.org/worg/org-contrib/babel/][org babel]].

   To enable that you can either ~(setq org-babel-clojure-backend 'babashka)~, which will always use babashka when
   using clojure as language, or you can add a header argument ~:backend babashka~, which will only apply to
   a specific source block. Note that you need to have babashka installed in your system.

   This code was forked from https://git.jeremydormitzer.com/jdormit/dotfiles/commit/5f9dbe53cea2b37fc89cc49f858f98387da99576
   with a few modifications.
   
** Support for deps.edn
   It supports setting deps.edn as a source block. To do that create a clojure source block like:

   #+begin_example
     ,#+name: deps-edn
     ,#+begin_src clojure
     {:deps org.clojure/tools.reader {:mvn/version "1.1.1"}}
     ,#+end_src
   #+end_example

   And add a ~:deps-edn~ attribute to your clojure source block, e.g.:
   #+begin_example
     ,#+begin_src clojure
     ,#+begin_src clojure :deps-edn deps-edn
     ; some clojure code
     ,#+end_src
   #+end_example
   
   To start the repl invoke ~my/ob-clojure-cider-jack-in~ from the source block you want to evaluate.
  
  #+begin_src emacs-lisp
    (defun ob-clojure-eval-with-bb (expanded params)
      "Evaluate EXPANDED code block with PARAMS using babashka."
      (unless (executable-find "bb")
        (user-error "Babashka not installed"))
      (let* ((stdin (let ((stdin (cdr (assq :stdin params))))
                      (when stdin
                        (elisp->clj
                         (org-babel-ref-resolve stdin)))))
             (input (cdr (assq :input params)))
             (file (make-temp-file "ob-clojure-bb" nil nil expanded))
             (command (concat (when stdin (format "echo %s | " (shell-quote-argument stdin)))
                              (format "bb %s -f %s"
                                      (cond
                                       ((equal input "edn") "")
                                       ((equal input "text") "-i")
                                       (t ""))
                                      (shell-quote-argument file))))
             (result (shell-command-to-string command)))
        (string-trim result)))

    (defun my/ob-clojure-deps-block-name ()
      (seq-let [_ _ params] (org-babel-get-src-block-info)
        (a-get params :deps-edn)))

    (defun my/ob-clojure-deps-block-body ()
      (when-let ((block-name (my/ob-clojure-deps-block-name)))
        (save-excursion
          (org-babel-goto-named-src-block block-name)
          (seq-let [_ body] (org-babel-get-src-block-info)
            body))))

    (defun my/ob-clojure-cider-jack-in-clj ()
      (interactive)
      (when-let ((deps-edn (my/ob-clojure-deps-block-body)))
        (write-region deps-edn nil (concat default-directory "deps.edn")))
      (let ((cider-allow-jack-in-without-project t))
        (cider-jack-in-clj '())))

    (defun org-babel-execute:clojure (body params)
      "Execute a block of Clojure code with Babel."
      (let* ((backend (if-let ((backend-s (a-get params :backend)))
                          (intern backend-s)
                        org-babel-clojure-backend))
             (expanded (org-babel-expand-body:clojure body params))
             (result-params (cdr (assq :result-params params)))
             result)
        (unless backend
          (user-error "You need to customize org-babel-clojure-backend"))
        (setq result
              (cond
               ((eq backend 'inf-clojure)
                (ob-clojure-eval-with-inf-clojure expanded params))
               ((eq backend 'cider)
                (progn
                  (when (not (cider-current-repl))
                    (error "no repl connected, run my/ob-clojure-cider-jack-in-clj"))
                  (ob-clojure-eval-with-cider expanded params)))
               ((eq backend 'slime)
                (ob-clojure-eval-with-slime expanded params))
               ((eq backend 'babashka)
                (ob-clojure-eval-with-bb expanded params))))
        (org-babel-result-cond result-params
          result
          (condition-case nil (org-babel-script-escape result)
            (error result)))))
  #+end_src
* Org Mode + Clojure Portal
  Function that shows the result of executing a org babel source block in [[https://github.com/djblue/portal][Portal.]]
  
  #+begin_src emacs-lisp
    (setq my/portal-nrepl-port 1900)

    (defconst my/portal-classpath-command
      "clojure -Spath -Sdeps '{:deps {djblue/portal {:mvn/version \"0.8.0\"}}}'")

    (defun my/portal-nrepl-port-open-p ()
      (condition-case nil
          (progn
            (make-network-process :name "nrepl-portal" :family 'ipv4 :host "localhost" :service my/portal-nrepl-port)
            (delete-process "nrepl-portal")
            t)
        (error nil)))

    (defun my/wait-for-portal-nrepl-port ()
      (let ((number-of-tries 0))
        (while (not (my/portal-nrepl-port-open-p))
          (when (> number-of-tries 20)
            (error "timeout waiting for port"))
          (setq number-of-tries (+ number-of-tries 1))
          (sleep-for 0.2))))

    (defun my/start-portal ()
      (when (not (my/portal-nrepl-port-open-p))
        (setq my/portal-process
              (start-process-shell-command "clojure-portal"
                                           "clojure-portal-output"
                                           (format "bb -cp `%s` --nrepl-server %s"
                                                   my/portal-classpath-command
                                                   my/portal-nrepl-port)))
        (my/wait-for-portal-nrepl-port)
        (setq my/portal-nrepl-connection
              (cider-connect `(:host "localhost" :port ,my/portal-nrepl-port)))))

    (defun my/eval-in-portal (code)
      (nrepl-send-sync-request
       `("op" "eval" "code" ,code)
       my/portal-nrepl-connection))

    (defun my/start-portal-instance ()
      (my/start-portal)
      (my/eval-in-portal
       "(require '[portal.api :as p])
        (defonce portal (atom nil))
        (reset! portal (p/open @portal nil))"))

    (defun my/send-to-portal (data)
      (my/start-portal-instance)
      (my/eval-in-portal
       (parseedn-print-str
        `(reset! @portal (quote ,data)))))

    (defun my/org-babel-execute-src-block-to-clojure-portal ()
      (interactive)
      (let* ((result (org-babel-execute-src-block)))
        (my/send-to-portal result)))
  #+end_src
* Microk8s Org-babel
  #+begin_src emacs-lisp
    ;; possibly require modes required for your language
    (define-derived-mode kubectl-mode yaml-mode "kubectl"
      "Major mode for editing kubectl templates."
      )



    ;; optionally define a file extension for this language
    (add-to-list 'org-babel-tangle-lang-exts '("kubectl" . "yaml"))

    ;; optionally declare default header arguments for this language
    (defvar org-babel-default-header-args:kubectl '((:action . "apply")(:context . nil)))

    ;; This function expands the body of a source code block by doing
    ;; things like prepending argument definitions to the body, it should
    ;; be called by the `org-babel-execute:kubectl' function below.
    (defun org-babel-expand-body:kubectl (body params &optional processed-params)
      "Expand BODY according to PARAMS, return the expanded body."
      ;(require 'inf-kubectl) : TODO check if needed
      body ; TODO translate params to yaml variables
    )

    ;; This is the main function which is called to evaluate a code
    ;; block.
    ;;
    ;; This function will evaluate the body of the source code and
    ;; return the results as emacs-lisp depending on the value of the
    ;; :results header argument
    ;; - output means that the output to STDOUT will be captured and
    ;;   returned
    ;; - value means that the value of the last statement in the
    ;;   source code block will be returned
    ;;
    ;; The most common first step in this function is the expansion of the
    ;; PARAMS argument using `org-babel-process-params'.
    ;;
    ;; Please feel free to not implement options which aren't appropriate
    ;; for your language (e.g. not all languages support interactive
    ;; "session" evaluation).  Also you are free to define any new header
    ;; arguments which you feel may be useful -- all header arguments
    ;; specified by the user will be available in the PARAMS variable.
    (defun org-babel-execute:kubectl (body params)
      "Execute a block of kubectl code with org-babel.
    This function is called by `org-babel-execute-src-block'"
      (let* ((vars (org-babel--get-vars params))
	     (action (if (assoc :action params) (cdr (assoc :action params)) "apply")))
	(message "executing kubectl source code block")
	(org-babel-eval-kubectl (concat "microk8s kubectl " action " -f" ) body)
	)
      ;; when forming a shell command, or a fragment of code in some
      ;; other language, please preprocess any file names involved with
      ;; the function `org-babel-process-file-name'. (See the way that
      ;; function is used in the language files)
      )


    (defun org-babel-eval-kubectl (cmd yaml)
      "Run CMD on BODY.
    If CMD succeeds then return its results, otherwise display
    STDERR with `org-babel-eval-error-notify'."
      (let ((err-buff (get-buffer-create " *Org-Babel Error*"))
	    (yaml-file (org-babel-temp-file "ob-kubectl-yaml-"))
	    (output-file (org-babel-temp-file "ob-kubectl-out-"))
	    exit-code)
	(with-temp-file yaml-file (insert yaml))
	(with-current-buffer err-buff (erase-buffer))
	(setq exit-code
	      (shell-command (concat cmd " " yaml-file) output-file err-buff)
	      )
	  (if (or (not (numberp exit-code)) (> exit-code 0))
	      (progn
		(with-current-buffer err-buff
		  (org-babel-eval-error-notify exit-code (buffer-string)))
		(save-excursion
		  (when (get-buffer org-babel-error-buffer-name)
		    (with-current-buffer org-babel-error-buffer-name
		      (unless (derived-mode-p 'compilation-mode)
			(compilation-mode))
		      ;; Compilation-mode enforces read-only, but Babel expects the buffer modifiable.
		      (setq buffer-read-only nil))))
		nil)
	    ; return the contents of output file
	    (with-current-buffer output-file (buffer-string)))))

    (add-to-list 'org-babel-load-languages '(kubectl .t))
  #+end_src
